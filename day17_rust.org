#+title: Adventure of Code, 2023, день 17, =Rust=

* Частина 1
:PROPERTIES:
:ID:       e6284851-b1c1-4e8f-a3f9-42ba60af32da
:END:

#+begin_src rust :noweb yes :mkdirp yes :tangle src/bin/day17_1.rs
  <<day17:Декларації>>

  <<day17:Визначення>>

  fn main() {
      <<day17:Прочитати-дані>>
      <<day17_1:Дії>>
      println!("{:?}", result);
  }
#+end_src

* Читання даних

#+begin_src rust :noweb-ref day17:Декларації
  use std::{fs, env, io::{self, BufRead}};
#+end_src

#+begin_src rust :noweb-ref day17:Прочитати-дані
  let args: Vec<String> = env::args().collect();
  let file = fs::File::open(&args[1]).unwrap();
  let lines = io::BufReader::new(file)
      .lines().map(|l| l.unwrap());
#+end_src

Створимо дошку.

#+begin_src rust :noweb-ref day17:Декларації
  use grid::Grid;
#+end_src

#+begin_src rust :noweb-ref day17:Визначення
  type Board = Grid<usize>;
#+end_src

#+begin_src rust :noweb-ref day17:Прочитати-дані
  let mut board = Board::new(0, 0);
  for line in lines {
      let mut row = Vec::new();
      for c in line.chars() {
          row.push(c.to_digit(10).unwrap() as usize);
      }
      board.push_row(row);
  }
  let (rows, cols) = (board.rows(), board.cols());
  println!("{:#?}", board);
#+end_src

* Позиції

Для простоти кодуємо позицію парою з номерів рядка і стовпця.

#+begin_src rust :noweb-ref day17:Визначення
  type Pos = (usize, usize);
#+end_src

* Напрямки

Визначимо напрямки за сторонами світу.

#+begin_src rust :noweb-ref day17:Декларації
  use strum::IntoEnumIterator;
  use strum_macros::EnumIter;
#+end_src

#+begin_src rust :noweb-ref day17:Визначення
  #[derive(EnumIter, PartialEq, Clone, Copy, Debug)]
  enum Dir { North, East, South, West }
#+end_src

* Шляхи
:PROPERTIES:
:ID:       795d38ca-1d26-437a-8330-d830411a64d0
:END:

/Шлях/ (=path=) представляє собою просто послідовність (~Vec~) позицій. Однак, задача вимагає обмежувати
кількість прямих ланок, тому для кожного шляху будемо також зберігати для шляха кількість позицій в
останній ланці і її напрямок. Нарешті, для оптимізації зберігатимемо в шляху також його /вартість/
(=cost=), яка є сумою втрат для усіх позицій в шляху.

Перелік шляхів будемо зберігати у звичайному векторі (~Vec~), однак, впорядковувати їх, розглядаючи
спочатку шляхи, які найбільш вірогідно виявляться ефективними.

#+begin_src rust :noweb-ref day17:Визначення
  type Path = (Vec<Pos>, usize, Dir, usize);
  type Paths = Vec<Path>;
#+end_src

При виборі наступного шляху можна використовувати дві евристики:

- спочатку розглядаємо найдовші шляхи;
- спочатку розглядати шляхи, які закінчуються найближче до позиції виходу;
- спочатку розглядати шляхи з найменшою вартістю.

Ці стратегії виглядають майже однаково ефективними, але третя стратегія стимулює розглядати в першу чергу
коротші шляхи, що може затягувати процес перебору, а перша --- навпаки, довші. Експериментально
визначено, що спочатку порівнюємо шляхи за довжиною, потім за /відстанню/ (=distance=), яку визначаємо як
відстнь кінця шляха від позиції виходу, а потім за вартістю.

Для порівняння визначимо /вагу/ (=weight=) шляха, яка представляє собою пару з відстані. Оскільки легше
обирати шляхи з кінця переліку, елементи ваги отримуємо в зворотньому порядку.

#+begin_src rust :noweb-ref day17:Визначення
  type Weight = (usize, cmp::Reverse<usize>, cmp::Reverse<usize>);

  fn weight(board: &Board, path: &Path) -> Weight {
      (path.0.len(),
       cmp::Reverse(distance(path.0.last().unwrap(), &(board.rows() - 1, board.cols() - 1))),
       cmp::Reverse(path.3))
  }
#+end_src

/Відстань/ (=distance=) обчислюється в "шаховому" сенсі, коли значення є просто сумою модулів різниць
координат.

#+begin_src rust :noweb-ref day17:Визначення
  fn distance(p1: &Pos, p2: &Pos) -> usize {
      ((p1.0 as isize - p2.0 as isize).abs()
          + (p1.1 as isize - p2.1 as isize).abs()) as usize
  }
#+end_src

Спочатку створюємо два шляха з верхнього лівого кута з напрямками на схід і південь. Тут вже треба
вставляти шляхи за вагою, тому спочатку знаходимо правильні позиції за допомогою
[[https://doc.rust-lang.org/std/primitive.slice.html#method.binary_search_by_key][binary_search_by_key]]. Зауважимо, що успішним цей пошук бути не може, оскільки кожен шлях в переліку має
бути унікальним.

Для оптимізації зарезервуємо ~1000~ шляхів в переліку.

#+begin_src rust :noweb-ref day17:Декларації
  use std::cmp;
#+end_src

#+begin_src rust :noweb-ref day17_1:Дії
  let mut paths: Paths = Paths::with_capacity(1000);

  for path in vec![
      (vec![(0, 0), (0, 1)], 2, Dir::East, *board.get(0, 1).unwrap()),
      (vec![(0, 0), (1, 0)], 2, Dir::South, *board.get(1, 0).unwrap())
  ] {
      let Err(i) = paths.binary_search_by_key(&weight(&board, &path), |p| { weight(&board, p) }) else {
          panic!("Path duplicate");
      };
      paths.insert(i, path);
  }
#+end_src

** Відлагодження

Для відлагодження створюємо таблицю символів, яку заповнюємо відповідно до шляху.

#+begin_src rust :noweb-ref day17:Визначення
  fn show(rows: usize, cols: usize, path: &Vec<Pos>) -> Grid<char> {
      let mut result = Grid::new(rows, cols);
      result.fill('.');
      for i in 1..path.len() {
          let (rin, cin) = path[i-1];
          let (rout, cout) = path[i];
          ,*result.get_mut(rout, cout).unwrap() =
              if rin < rout {
                  'v'
              } else if rin > rout {
                  '^'
              } else if cin < cout {
                  '>'
              } else if cin > cout {
                  '<'
              } else {
                  '?'
              };
      }
      result
  }
#+end_src

* COMMENT Пощук шляхів

Ми шукаємо оптимальний шлях, тому для відсічки задамо /межу/ (=limit=) відсічки. /Завершеним/
(=complete=) шляхом є шлях, який закінчується в нижньому правому куті дошки, інші шляхи вважаються
незавершеними. Складність в тому, що для незавершених шляхів неможливо визначити межу відсічки, оскільки
будь-який незавершений шлях може стати краще іншого. Однак, як тільки знайдено хоча б один завершений
шлях, його вага стає межою для усіх інших шляхів. Для простоти вважатимо, що, поки не знайдено хоча б
один повний шлях, меша є "нескінченною" (яка завдається константою ~MAX~), а як тільки межа знайдена, для
кожного нового знайденого повного шляха вона корегується в сторону зменшення.

#+begin_src rust :noweb-ref day17_1:Дії
  let mut limit = usize::MAX;
#+end_src

Перебираємо шляхи, поки їх перелік не стане пустим.

#+begin_src rust :noweb yes :noweb-ref day17_1:Дії
  let mut k = 0;
  while let Some((path, len, din, w)) = paths.pop() {
      k += 1;
      if k % 100_000 == 0 {
          println!("{} {}", k, paths.len());
          println!("{:?} {} {:?}, {}", path.clone(), len, din, w);
      }
      <<day17_1:Обробити-шлях>>
  }
#+end_src

Відокремимо останню позицію.

#+begin_src rust :noweb yes :noweb-ref day17_1:Обробити-шлях
  let &pos = path.last().unwrap();
#+end_src

Якщо шлях завершений (остання позиція в правому нижньому куті), корегуємо межу і продовжуємо.

#+begin_src rust :noweb yes :noweb-ref day17_1:Обробити-шлях
  if pos == (rows - 1, cols - 1) {
      limit = limit.min(w);
      println!("{} {:?}", limit, path);
      println!("{:#?}", show(rows, cols, &path));
      continue;
  }
#+end_src

Якщо остання вага шляха більше межі, відкидаємо шлях.

#+begin_src rust :noweb yes :noweb-ref day17_1:Обробити-шлях
  if w >= limit { continue; }
#+end_src

Перебираємо усі напрямки і створюємо нові шляхи.

#+begin_src rust :noweb yes :noweb-ref day17_1:Обробити-шлях
  for dout in Dir::iter() {
      <<day17_1:Обробити-напрямок>>
  }
#+end_src

Враховуємо, що напрямок має змінюватись не пізніше кожного третього кроку.

#+begin_src rust :noweb yes :noweb-ref day17_1:Обробити-напрямок
  if len == 3 && dout == din { continue; }
#+end_src

Обчислимо нову позицію. Для простоти кодуємо вихід за межі дошки на північ (~r<0~) і захід (~c<0~)
значеннями розмірів.

#+begin_src rust :noweb yes :noweb-ref day17_1:Обробити-напрямок
  let (mut r, mut c) = pos;
  match dout {
      Dir::North => { r = if r == 0 { rows } else { r - 1 }; },
      Dir::East => { c += 1; },
      Dir::South => { r += 1; },
      Dir::West => { c = if c == 0 { cols } else { c - 1 }; }
  };
#+end_src

Якщо нова позиція виходить за межі дошки, ігноруємо її.

#+begin_src rust :noweb yes :noweb-ref day17_1:Обробити-напрямок
  if r == rows || c == cols { continue; }
#+end_src

Якщо вага позиції більше межі, ігноруємо її.

#+begin_src rust :noweb yes :noweb-ref day17_1:Обробити-напрямок
  if w + board.get(r, c).unwrap() >= limit { continue; }
#+end_src

Якщо позиція вже входить в шлях, ігноруємо її.

#+begin_src rust :noweb yes :noweb-ref day17_1:Обробити-напрямок
  if path.contains(&(r, c)) { continue; }
#+end_src

Додаємо новий шлях з новою позицією.

#+begin_src rust :noweb yes :noweb-ref day17_1:Обробити-напрямок
  let mut path = path.clone();
  path.push((r, c));
  let path = (path, if dout == din { len + 1 } else { 1 }, dout, w + board.get(r, c).unwrap());
#+end_src

Вставляємо шлях на своє місце в переліку за допомогою двійкового пошуку. Тут складність в тому, що ключі
можуть дублюватися, тому двійковий пошук може знайти паразитний "дубль", інший шлях з тим саме ключем. В
такому разі вставляємо новий шлях в кінець, як найбільш перспективний.

#+begin_src rust :noweb yes :noweb-ref day17_1:Обробити-напрямок
  let i = match paths.binary_search_by_key(&weight(&board, &path), |p| weight(&board, p)) {
      Err(i) => i,
      Ok(i) => i + 1
  };
  paths.insert(i, path);
#+end_src

* Тестування

Перевіримо оптимальний шлях.

#+begin_src rust :noweb yes :noweb-ref day17:Визначення
  fn read_board(name: &str) -> Board {
      let file = fs::File::open(name).unwrap();
      let lines = io::BufReader::new(file)
          .lines().map(|l| l.unwrap());
      let mut board = Board::new(0, 0);
      for line in lines {
          let mut row = Vec::new();
          for c in line.chars() {
              row.push(c.to_digit(10).unwrap() as usize);
          }
          board.push_row(row);
      }
      board
  }

  fn cost(board: &Board, path: &Vec<Pos>) -> usize {
      path.iter().skip(1).fold(0, |a, (r, c)| a + board.get(*r, *c).unwrap())
  }

  #[test]
  fn test_optimal() {
      let board = read_board("day17_debug.txt");
      let opt = vec![
          (0, 0), (0, 1), (0, 2),
          (1, 2), (1, 3), (1, 4), (1, 5),
          (0, 5), (0, 6), (0, 7), (0, 8),
          (1, 8),
          (2, 8), (2, 9), (2, 10),
          (3, 10), (4, 10),
          (4, 11), (5, 11), (6, 11), (7, 11),
          (7, 12), (8, 12), (9, 12), (10, 12),
          (10, 11), (11, 11), (12, 11), (12, 12)
      ];
      println!("{:#?}", show(13, 13, &opt));
      assert_eq!(cost(&board, &opt), 102);
  }
#+end_src

* Рекурсивний обхід

Пряма реалізація нагадує рекурсивний обхід варіантів з використанням штучного "стеку" у вигляді переліку
шляхів. Можливо, що більшість часу відбирає перетворення структур, в той час, як зберігання структур на
стеку може значно пришвидшити обробку.

Нехай рекурсивна функція ~mincost~ приймає шлях ~path~ та необхідні для ефективності характеристики:
дошку ~board~, поточну позицію ~pos~, кількість позицій до завершення ланки ~rest~, поточний напрямок
~din~, вартість шляха ~cost~ та поточний поріг ~limit~. Ця функція повертає мінімальну вартість для
продовження шляху в цій точці, або нічого, якщо немає ефективних шляхів з цієї позиції.

Для відлагодження додамо також параметр ~depth~. Коли він дорівнює ~0~, просто повертаємо поточне
значення ~cost~.

Для відлагодження введемо параметр ~step~, який буде підраховувати загальну кількість опрацьованих шляхів
і показувати прогрес.

#+begin_src rust :noweb yes :noweb-ref day17:Визначення
  fn mincost(
      board: &Board, path: &Vec<Pos>, pos: Pos, rest: usize, din: Dir, cost: usize, limit: usize, depth: usize, step: &mut usize
  ) -> Option<usize> {
      ,*step += 1;
      if *step % 10_000_000 == 0 { println!("{} {} {}", *step, limit, usize::MAX - depth); }
      if depth == 0 {
          //println!("{} {:?}", cost, path);
          return Some(cost);
      }
      <<day17:mincost:Дії>>
  }
#+end_src

Зробимо виклик для початкової позиції.

#+begin_src rust :noweb yes :noweb-ref day17_1:Дії
  let mut step = 0;
  let result = mincost(&board, &vec![(0, 0)], (0, 1), 1, Dir::East, 0, usize::MAX, usize::MAX, &mut step)
      .min(mincost(&board, &vec![(0, 0)], (1, 0), 1, Dir::South, 0, usize::MAX, usize::MAX, &mut step));
#+end_src

Якщо позиція є кінцевою, обчислюємо і повертаємо вартість шляха. Для зручності визначимо синоними для
кількості рядків (~rows~) і стовбців (~cols~), а також обрахуємо нову вартість шляха.

Обчислена вартість шляха не може бути більше межі.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Дії
  let (rows, cols) = (board.rows(), board.cols());
  let cost = cost + *board.get(pos.0, pos.1).unwrap();
  if pos == (rows - 1, cols - 1) {
      println!("{} {}", limit, cost);
      //println!("{:#?}", show(rows, cols, &path));
      return Some(cost);
  }
#+end_src

Утворимо новий шлях, додавши до нього поточну позицію.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Дії
  let mut path = path.clone();
  path.push(pos);
#+end_src

Перебираємо усі напрямки і збираємо в перелік набори координат нових позицій, їх напрямки і вартості.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Дії
  let mut variants = Dir::iter()
      .filter_map(|dout| {
          <<day17:mincost:Обробити-напрямок>>
          Some(((r, c), dout, *board.get(r, c).unwrap()))
      })
      .collect::<Vec<_>>();
#+end_src

Відкинемо той саме напрямок, якщо поточний залишок дорівнює нулю.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Обробити-напрямок
  if rest == 0 && dout == din { return None; }
#+end_src

Обчислюємо нову позицію.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Обробити-напрямок
  let (mut r, mut c) = pos;
  match dout {
      Dir::North => { r = if r == 0 { return None; } else { r - 1 }; },
      Dir::East => { c += 1; },
      Dir::South => { r += 1; },
      Dir::West => { c = if c == 0 { return None; } else { c - 1 }; }
  };
#+end_src

Якщо нова позиція виходить за межі дошки, відкидаємо напрямок.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Обробити-напрямок
  if r == rows || c == cols { return None; }
#+end_src

Якщо вартість шляха для нової позиції більше межі, відкидаємо напрямок.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Обробити-напрямок
  if cost + *board.get(r, c).unwrap() >= limit { return None; }
#+end_src

Якщо нова позиція вже входить до шляху, напрямок також відкидається.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Обробити-напрямок
  if path.contains(&(r, c)) { return None; }
#+end_src

Відсортуємо перелік варіантів за вагою, тобто спочатку за відстанню від кінцевої точки, а потім за вартістю.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Дії
  variants.sort_by_key(|v| (distance(&v.0, &(rows - 1, cols - 1)), v.2));
#+end_src

Для кожного варіанта обчислимо рекурсивно мінімальну вартість шляха і потім повернемо мінімальну вартість
з усіх. Під час перебору уточнюємо межу.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Дії
  let mut limit = limit;
  variants.iter()
      .filter_map(|&(pos, dout, _)| {
          let rest = if dout == din { rest - 1 } else { 2 };
          let result = mincost(&board, &path, pos, rest, dout, cost, limit, depth - 1, step);
          if let Some(result) = result {
              limit = limit.min(result);
          }
          result
      })
      .min()        
#+end_src
