#+title: Adventure of Code, 2023, день 17, =Rust=

* Частина 1
:PROPERTIES:
:ID:       e6284851-b1c1-4e8f-a3f9-42ba60af32da
:END:

#+begin_src rust :noweb yes :mkdirp yes :tangle src/bin/day17_1.rs
  <<day17:Декларації>>

  <<day17:Визначення>>

  fn main() {
      <<day17:Прочитати-дані>>
      let result = 0;
      <<day17_1:Дії>>
      println!("{:?}", result);
  }
#+end_src

* Читання даних

#+begin_src rust :noweb-ref day17:Декларації
  use std::{fs, env, io::{self, BufRead}};
#+end_src

#+begin_src rust :noweb-ref day17:Прочитати-дані
  let args: Vec<String> = env::args().collect();
  let file = fs::File::open(&args[1]).unwrap();
  let lines = io::BufReader::new(file)
      .lines().map(|l| l.unwrap());
#+end_src

Створимо дошку.

#+begin_src rust :noweb-ref day17:Декларації
  use grid::Grid;
#+end_src

#+begin_src rust :noweb-ref day17:Визначення
  type Board = Grid<usize>;
#+end_src

#+begin_src rust :noweb-ref day17:Прочитати-дані
  let mut board = Board::new(0, 0);
  for line in lines {
      let mut row = Vec::new();
      for c in line.chars() {
          row.push(c.to_digit(10).unwrap() as usize);
      }
      board.push_row(row);
  }
  let (rows, cols) = (board.rows(), board.cols());
  println!("{:#?}", board);
#+end_src

* Позиції

Для простоти кодуємо позицію парою з номерів рядка і стовпця.

#+begin_src rust :noweb-ref day17:Визначення
  type Pos = (usize, usize);
#+end_src

/Відстань/ (=distance=) між двома позиціями обчислюється в "шаховому" сенсі, коли значення є просто сумою
модулів різниць координат.

#+begin_src rust :noweb-ref day17:Визначення
  fn distance(p1: &Pos, p2: &Pos) -> usize {
      ((p1.0 as isize - p2.0 as isize).abs()
          + (p1.1 as isize - p2.1 as isize).abs()) as usize
  }
#+end_src

* Напрямки

Визначимо напрямки за сторонами світу.

#+begin_src rust :noweb-ref day17:Декларації
  use strum::IntoEnumIterator;
  use strum_macros::EnumIter;
#+end_src

#+begin_src rust :noweb-ref day17:Визначення
  #[derive(EnumIter, PartialEq, PartialOrd, Eq, Ord, Hash, Clone, Copy, Debug)]
  enum Dir { North, East, South, West }
#+end_src

* Шляхи
:PROPERTIES:
:ID:       795d38ca-1d26-437a-8330-d830411a64d0
:END:

/Шлях/ (=path=) представляє собою просто послідовність позицій. Однак, в процесі необхідно швидко
перевіряти належність позиції до шляху. Для ефективного рішення будемо зберігати шлях у вигляді таблиці з
порядковими номерами окремих позицій.

#+begin_src rust :noweb-ref day17:Визначення
  type Path = Grid<usize>;
#+end_src

* Межі

При переборі ми використовуємо /межу/ (=limit=), яка дозволяє відкинути неповні шляхі, вартість яких
більше, ніж вже знайдена мінімальна вартість повного шляху. Однак, ця евристика працює погано, оскільки в
більшості випадків неповні шляхи коштують менше, ніж повний шлях.

Ускладнимо евристику, призначимо кожній позиції свою межу, яка найменшу вказує вартість шляху з
початкової позиції. Коли розглядається нова позиція шляху, її межа порівнюється з вартістю знайденого
шляху, який включає цю позицію. Якщо вага нового шляху не менше межі, позиція відкидається. Тобто, якщо
новий шлях не зменшує вже знайдену мінімальну вартість для нової позиції, нема сенсу її розглядати.

Ця евристика не є точною, оскільки, теоретично, може існувати ситуація, коли новий шлях з більшою
вартістю в подальшому виявиться більш ефективним. Однак, відсутність інших ідей вимагає спробувати хоча б
це.

Еврістику було уточнено, оскільки треба враховувати не тільки позицію, але також напрямок заходу та
поточний залишок перед поворотом. Тому будемо зберігати межі (для ефективності) у вигляді хеш-мапи
(~HashMap~), у якої ключем є набір з позиції, напрямку та залишку, а значенням --- вартість позиції.

Для хеш-мапи ключ має реалізовувати специфічний трейт ~Hash~, тому визначимо ключ мапи як спеціальну
структуру ~Key~.

#+begin_src rust :noweb-ref day17:Декларації
  use std::collections::HashMap;
#+end_src

#+begin_src rust :noweb-ref day17:Визначення
  #[derive(PartialEq, Hash)]
  struct Key(Pos, Dir, usize);

  type Limits = HashMap<Key, usize>;
#+end_src

* Рекурсивний обхід

Виявився неефективним.

Пряма реалізація нагадує рекурсивний обхід варіантів з використанням штучного "стеку" у вигляді переліку
шляхів. Можливо, що більшість часу відбирає перетворення структур, в той час, як зберігання структур на
стеку може значно пришвидшити обробку.

Нехай рекурсивна функція ~mincost~ приймає шлях ~path~ та необхідні для ефективності характеристики:
дошку ~board~, поточну позицію ~pos~, кількість позицій до завершення ланки ~rest~, поточний напрямок
~din~ (=direction in=), вартість шляха ~cost~ та поточний поріг ~limit~. Ця функція повертає мінімальну
вартість для продовження шляху в цій точці, або нічого, якщо немає ефективних шляхів з цієї позиції.

Для відлагодження додамо також параметр ~depth~. Коли він дорівнює ~0~, просто повертаємо поточне
значення ~cost~.

Для відлагодження введемо параметр ~step~, який буде підраховувати загальну кількість опрацьованих шляхів
і показувати прогрес.

Для ефективності шлях дозволяє зміни, отже, використовується єдина структура для усіх кроків.

В таблиці ~limits~, яка спочатку заповнена максимальними значеннями (~usize::MAX~), зберігаємо межі для
окремих позицій. Ця структура також єдина для усіх викликів.

#+begin_src rust :noweb yes :noweb-ref day17:Визначення
  fn mincost(
      board: &Board, path: &mut Path, pos: Pos,
      rest: usize, din: Dir,
      cost: usize, limit: usize, limits: &mut Limits,
      depth: usize, step: &mut usize
  ) -> Option<usize> {
      ,*step += 1;
      if *step % 10_000_000 == 0 { println!("{} {} {}", *step, limit, board.rows() * board.cols() - depth); }
      if depth == 0 {
          //println!("{} {:?}", cost, path);
          return Some(cost);
      }
      <<day17:mincost:Дії>>
      result
  }
#+end_src

Створимо мапу меж.

#+begin_src rust :noweb yes :noweb-ref day17_1:Дії
  let mut limits = Limits::new();
#+end_src

Підготуємо шлях.

#+begin_src rust :noweb yes :noweb-ref day17_1:Дії
  let mut path = Path::new(rows, cols);
  path.fill(0);
  ,*path.get_mut(0, 0).unwrap() = 1;
#+end_src

Виконуємо перший виклик. Повна глибина дорівнює кількості позицій на дошці мінус ~1~, яка резервує
початкову позицію.

#+begin_src rust :noweb yes :noweb-ref day17_1:Дії
  let mut step = 0;
  let result1 = mincost(
      &board, &mut path, (0, 1),
      1, Dir::East,
      0, usize::MAX, &mut limits,
      rows * cols - 1, &mut step);
  println!("First: {:?}", result1);
#+end_src

Для другого виклику встановлюємо, за можливості, нову межу.

#+begin_src rust :noweb yes :noweb-ref day17_1:Дії
  let limit = result1.unwrap_or(usize::MAX);

  let result2 = mincost(
      &board, &mut path, (1, 0),
      1, Dir::South,
      0, limit, &mut limits,
      rows * cols - 1, &mut step);
  println!("Result: {:?} {:?}", result1, result2);
#+end_src

Якщо позиція є кінцевою, обчислюємо і повертаємо вартість шляха. Для зручності визначимо синоними для
кількості рядків (~rows~) і стовбців (~cols~), а також обрахуємо нову вартість шляха.

Обчислена вартість шляха не може бути більше межі.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Дії
  let (rows, cols) = (board.rows(), board.cols());
  let cost = cost + *board.get(pos.0, pos.1).unwrap();
  limits.insert(Key(pos, din, rest), cost);
  if pos == (rows - 1, cols - 1) {
      println!("{} {}", limit, cost);
      //println!("{:#?}", show(rows, cols, &path));
      return Some(cost);
  }
#+end_src

Утворимо новий шлях, додавши до нього поточну позицію. Пізніше треба буде прибрати цю позицію.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Дії
  ,*path.get_mut(pos.0, pos.1).unwrap() = rows * cols - depth;
#+end_src

Перебираємо усі напрямки і збираємо в перелік набори координат нових позицій, їх напрямки і вартості.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Дії
  let mut variants = Dir::iter()
      .filter_map(|dout| {
          <<day17:mincost:Обробити-напрямок>>
          Some(((r, c), dout, *board.get(r, c).unwrap()))
      })
      .collect::<Vec<_>>();
#+end_src

Відкинемо той саме напрямок, якщо поточний залишок дорівнює нулю.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Обробити-напрямок
  if rest == 0 && dout == din { return None; }
#+end_src

Обчислюємо нову позицію.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Обробити-напрямок
  let (mut r, mut c) = pos;
  match dout {
      Dir::North => { r = if r == 0 { return None; } else { r - 1 }; },
      Dir::East => { c = if c == cols - 1 { return None } else { c + 1 }; },
      Dir::South => { r = if r == rows - 1 { return None } else { r + 1 }; },
      Dir::West => { c = if c == 0 { return None; } else { c - 1 }; }
  };
#+end_src

Якщо вартість шляха для нової позиції більше межі, відкидаємо напрямок. При цьому перевіряємо не тільки
загальну межу, так і межу для конкретної позиції.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Обробити-напрямок
  if cost + *board.get(r, c).unwrap() >= limit { return None; }
  let rest = if dout == din { rest - 1 } else { 2 };
  if cost + *board.get(r, c).unwrap() >= *limits.get(&Key((r, c), dout, rest)).unwrap_or(&usize::MAX) { return None; }
#+end_src

Якщо нова позиція вже входить до шляху, напрямок також відкидається.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Обробити-напрямок
  if *path.get(r, c).unwrap() > 0 { return None; }
#+end_src

Відсортуємо перелік варіантів за вагою, тобто спочатку за відстанню від кінцевої точки, а потім за вартістю.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Дії
  variants.sort_by_key(|v| (distance(&v.0, &(rows - 1, cols - 1)), v.2));
#+end_src

Для кожного варіанта обчислимо рекурсивно мінімальну вартість шляха і потім повернемо мінімальну вартість
з усіх. Під час перебору уточнюємо межу.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Дії
  let mut limit = limit;
  let result = variants.iter()
      .filter_map(|&(pos, dout, _)| {
          let rest = if dout == din { rest - 1 } else { 2 };
          let result = mincost(&board, path, pos, rest, dout, cost, limit, limits, depth - 1, step);
          if let Some(result) = result { limit = result; }
          result
      })
      .min();
#+end_src

Вилучаємо позицію з шляху.

#+begin_src rust :noweb yes :noweb-ref day17:mincost:Дії
  ,*path.get_mut(pos.0, pos.1).unwrap() = 0;
#+end_src

